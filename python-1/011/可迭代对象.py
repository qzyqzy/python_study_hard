# 目前接触到的可迭代对象
# str  list   tuple  dic  set  range 文件句柄等

# int，bool 不可迭代

# python 中 但凡内部含有 __iter__ 方法的对象，都是可迭代对象

# dir() 判断一个对象具有什么方法
# 会返回一个列表 ['__add__', '__class__', '__contains__', '__delattr__', '__dir__'....]
s = 'name'
print(dir(s))

# 判断一个对象是否可迭代
print(('__iter__' in dir(s)))  # True

"""
    从字面意思来说：可迭代对象就是一个可以重复取值的实实在在的东西
    从专业角度来说：但凡内部含有__iter__方法的对象，都是可迭代对象
    可迭代对象可以通过判断该对象是否有’__iter__’方法来判断
"""

"""
    可迭代对象的优点
    可以直观的查看里面的数据
"""

"""
    可迭代对象的缺点：
    1. 占用内存
    2. 可迭代对象不能迭代取值（除去索引，key以外）
"""

# 在python中，内部含有'__iter__'方法并且含有'__next__'方法的对象就是迭代器
# 只有文件句柄是迭代器(包含__iter__、__next__)

# 将可迭代对象转化为迭代器
# '__iter___()' 或者 iter(seft)
lst = [1, 12, 3]
print(('__next__' in dir(lst)))  # False

lst1 = lst.__iter__()
print(('__next__' in dir(lst1)))  # True

# 迭代器取值
# 迭代器是利用__next__()进行取值的
# 如果迭代器取值完毕再次调用会报错

lst2 = iter([1])
print(lst2.__next__())  # 1
#  报错  print(lst2.__next__())


# for循环的内部机制是：将可迭代对象转换成迭代器，然后利用next进行取值，最后利用异常处理处理StopIteration抛出的异常

lst3 = [11, 12, 13]
lst4 = iter(lst3)
while True:
    # 利用异常处理终止循环
    try:
        print(lst4.__next__())
    except StopIteration:
        break

# 可迭代对象与迭代器对比
'''
    可迭代对象
    是一个私有的方法比较多，操作灵活（比如列表，字典的增删改查，字符串的常用操作方法等）,比较直观，但是占用内存，而且不能直接通过循环迭代取值的这么一个数据集
    当你侧重于对于数据可以灵活处理，并且内存空间足够，将数据集设置为可迭代对象是明确的选择   
'''

'''
    迭代器 
    是一个非常节省内存，可以记录取值位置，可以直接通过循环+next方法取值，但是不直观，操作方法比较单一的数据集
    当你的数据量过大，大到足以撑爆你的内存或者你以节省内存为首选因素时，将数据集设置为迭代器是一个不错的选择。（可参考为什么python把文件句柄设置成迭代器）
'''
